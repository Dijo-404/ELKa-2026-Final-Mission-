#!/usr/bin/env python3
"""
Delivery Mission - Payload Drop Drone Logic

Drone 2 (Delivery) workflow:
1. Read targets from targets.json (generated by Scout)
2. Split targets into batches of PAYLOAD_CAPACITY
3. For each batch:
   - Arm and takeoff
   - Fly to each target
   - Hover and trigger payload drop (servo)
   - RTL after batch complete
   - Wait for user refill confirmation (if more batches)
"""

import json
import logging
import time
from typing import List, Optional
from dataclasses import dataclass

from config import MissionConfig
from drone_controller import DroneController

logger = logging.getLogger(__name__)


@dataclass
class Target:
    """Target location for payload delivery."""
    id: int
    lat: float
    lon: float
    alt: float
    delivered: bool = False
    
    @classmethod
    def from_dict(cls, data: dict) -> 'Target':
        return cls(
            id=data.get('id', 0),
            lat=data.get('lat', 0.0),
            lon=data.get('lon', 0.0),
            alt=data.get('alt', 15.0),
            delivered=data.get('delivered', False)
        )


class DeliveryMission:
    """
    Delivery drone mission controller.
    
    Executes payload drops at detected target locations
    in batches based on payload capacity.
    """
    
    def __init__(self, config: MissionConfig = None):
        """
        Initialize Delivery mission.
        
        Args:
            config: Mission configuration
        """
        self.config = config or MissionConfig()
        
        # Components
        self.drone: Optional[DroneController] = None
        
        # Mission state
        self.targets: List[Target] = []
        self.batches: List[List[Target]] = []
        self.current_batch_index = 0
        self.current_target_index = 0
        self.deliveries_completed = 0
        
        # Control flags
        self.running = False
        self.abort_requested = False
    
    def load_targets(self, targets_file: str = None) -> bool:
        """
        Load targets from JSON file.
        
        Args:
            targets_file: Path to targets.json
            
        Returns:
            True if targets loaded successfully
        """
        filepath = targets_file or self.config.get_targets_path()
        
        try:
            with open(filepath, 'r') as f:
                data = json.load(f)
            
            targets_data = data.get('targets', [])
            
            if not targets_data:
                logger.error("No targets found in file")
                return False
            
            self.targets = [Target.from_dict(t) for t in targets_data]
            logger.info(f"Loaded {len(self.targets)} targets from {filepath}")
            
            # Create batches
            self._create_batches()
            
            return True
            
        except FileNotFoundError:
            logger.error(f"Targets file not found: {filepath}")
            return False
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in targets file: {e}")
            return False
        except Exception as e:
            logger.error(f"Failed to load targets: {e}")
            return False
    
    def _create_batches(self):
        """Split targets into batches based on payload capacity."""
        capacity = self.config.PAYLOAD_CAPACITY
        self.batches = []
        
        for i in range(0, len(self.targets), capacity):
            batch = self.targets[i:i + capacity]
            self.batches.append(batch)
        
        logger.info(f"Created {len(self.batches)} delivery batches "
                   f"(capacity: {capacity})")
    
    def setup(self) -> bool:
        """
        Set up mission components.
        
        Returns:
            True if setup successful
        """
        logger.info("=" * 60)
        logger.info("DELIVERY MISSION - SETUP")
        logger.info("=" * 60)
        
        # Initialize drone controller
        logger.info(f"Preparing drone controller for {self.config.DELIVERY_CONNECTION}...")
        self.drone = DroneController(
            self.config.DELIVERY_CONNECTION,
            baud=self.config.DELIVERY_BAUD,
            name=self.config.DELIVERY_NAME
        )
        
        logger.info("Setup complete!")
        logger.info("=" * 60)
        
        return True
    
    def connect_drone(self) -> bool:
        """
        Connect to the Delivery drone.
        
        Returns:
            True if connected successfully
        """
        if not self.drone:
            logger.error("Drone controller not initialized")
            return False
        
        return self.drone.connect(timeout=self.config.CONNECTION_TIMEOUT)
    
    def drop_payload(self) -> bool:
        """
        Execute payload drop at current position.
        
        Triggers servo and hovers for DROP_DURATION.
        
        Returns:
            True if drop executed
        """
        logger.info("Executing payload drop...")
        
        # Trigger servo to drop position
        self.drone.set_servo(
            self.config.DROP_SERVO_CHANNEL,
            self.config.DROP_SERVO_PWM
        )
        
        # Hover for drop duration
        logger.info(f"Hovering for {self.config.DROP_DURATION}s...")
        time.sleep(self.config.DROP_DURATION)
        
        # Reset servo to load position
        self.drone.set_servo(
            self.config.DROP_SERVO_CHANNEL,
            self.config.LOAD_SERVO_PWM
        )
        
        logger.info("Payload dropped!")
        return True
    
    def wait_for_refill(self, batch_num: int, total_batches: int) -> bool:
        """
        Wait for user confirmation that payload has been refilled.
        
        SAFETY CRITICAL: Only prompts user after verifying:
        1. Drone altitude is near 0 (landed)
        2. Drone is disarmed
        If still armed, forces disarm before prompt.
        
        Args:
            batch_num: Current batch number (1-indexed)
            total_batches: Total number of batches
            
        Returns:
            True if user confirms refill, False if user cancels
        """
        # =====================================================================
        # SAFETY CHECK 1: Verify altitude is near 0 (landed)
        # =====================================================================
        if self.drone:
            loc = self.drone.get_location()
            if loc:
                _, _, alt = loc
                if alt > 1.0:
                    logger.warning(f"Cannot refill - drone still airborne at {alt:.1f}m!")
                    logger.info("Waiting for landing...")
                    self.drone.wait_for_land(timeout=120.0)
            
            # =====================================================================
            # SAFETY CHECK 2: Verify drone is disarmed
            # =====================================================================
            if self.drone.is_armed():
                logger.warning("Drone still armed - force disarming for refill safety...")
                self.drone.disarm()
                time.sleep(1.0)
            
            # Double-check via heartbeat
            if self.drone.query_armed_state():
                logger.error("CRITICAL: Drone still armed after disarm attempt!")
                logger.error("Manually disarm before refilling payload!")
        
        # =====================================================================
        # SAFE TO SHOW REFILL PROMPT
        # =====================================================================
        print("\n" + "=" * 60)
        print(f"REFILL REQUIRED - DRONE SAFE")
        print("=" * 60)
        print(f"âœ“ Drone landed and disarmed")
        print(f"Batch {batch_num}/{total_batches} complete.")
        print(f"Deliveries this batch: {self.config.PAYLOAD_CAPACITY}")
        print(f"Remaining batches: {total_batches - batch_num}")
        print(f"Remaining targets: {len(self.targets) - self.deliveries_completed}")
        print()
        print(">>> Please reload the payload! <<<")
        print("=" * 60)
        
        while True:
            response = input("\nPress ENTER when refill complete (or 'q' to abort): ").strip().lower()
            
            if response == 'q':
                logger.warning("Mission aborted by user")
                return False
            
            if response == '':
                logger.info("Refill confirmed - continuing mission")
                return True
    
    def run(self) -> int:
        """
        Execute the Delivery mission.
        
        Returns:
            Number of successful deliveries
        """
        if not self.targets:
            logger.error("No targets loaded")
            return 0
        
        logger.info("=" * 60)
        logger.info("DELIVERY MISSION - EXECUTING")
        logger.info(f"Total targets: {len(self.targets)}")
        logger.info(f"Batches: {len(self.batches)}")
        logger.info(f"Payload capacity: {self.config.PAYLOAD_CAPACITY}")
        logger.info("=" * 60)
        
        self.running = True
        self.deliveries_completed = 0
        
        try:
            for batch_idx, batch in enumerate(self.batches):
                if self.abort_requested:
                    logger.warning("Mission abort requested")
                    break
                
                self.current_batch_index = batch_idx + 1
                
                logger.info(f"\n{'='*60}")
                logger.info(f"BATCH {self.current_batch_index}/{len(self.batches)}")
                logger.info(f"Targets in batch: {len(batch)}")
                logger.info("=" * 60)
                
                # Execute batch delivery
                batch_success = self._execute_batch(batch)
                
                if not batch_success:
                    logger.error("Batch execution failed")
                    break
                
                # Check if more batches remain
                if batch_idx < len(self.batches) - 1:
                    # Wait for refill
                    if not self.wait_for_refill(
                        self.current_batch_index, 
                        len(self.batches)
                    ):
                        break
        
        except KeyboardInterrupt:
            logger.warning("Mission interrupted by user")
            if self.drone and self.drone.is_armed():
                logger.info("Triggering RTL to home position...")
                self.drone.rtl()
        
        except Exception as e:
            logger.error(f"Mission error: {e}")
            if self.drone and self.drone.is_armed():
                logger.info("Emergency RTL to home position...")
                self.drone.rtl()
        
        finally:
            self.running = False
            self._cleanup()
        
        logger.info("=" * 60)
        logger.info("DELIVERY MISSION - COMPLETE")
        logger.info(f"Successful deliveries: {self.deliveries_completed}/{len(self.targets)}")
        logger.info("=" * 60)
        
        return self.deliveries_completed
    
    def _execute_batch(self, batch: List[Target]) -> bool:
        """
        Execute delivery for a single batch.
        
        Args:
            batch: List of targets in this batch
            
        Returns:
            True if batch completed successfully
        """
        # 1. Connect to drone
        logger.info("[1/5] Connecting to drone...")
        if not self.connect_drone():
            logger.error("Failed to connect to drone")
            return False
        
        # 2-4. Arm and Takeoff (using safety-enhanced method)
        logger.info("[2/4] Executing robust arm and takeoff sequence...")
        if not self.drone.arm_and_takeoff(self.config.DELIVERY_ALTITUDE):
            logger.error("Arm and takeoff failed")
            self.drone.disarm()  # Ensure disarmed
            return False
        
        # 5. Execute deliveries
        logger.info("[3/4] Executing deliveries...")
        
        for i, target in enumerate(batch):
            if self.abort_requested:
                break
            
            self.current_target_index = i + 1
            
            logger.info(f"\nTarget {self.current_target_index}/{len(batch)}: "
                       f"ID={target.id} ({target.lat:.6f}, {target.lon:.6f})")
            
            # Navigate to target
            if not self.drone.goto(
                target.lat, 
                target.lon, 
                self.config.DELIVERY_ALTITUDE
            ):
                logger.warning(f"Navigation to target {target.id} failed")
                continue
            
            # Wait for arrival at cruise altitude
            if not self.drone.wait_for_arrival(
                target.lat, 
                target.lon, 
                tolerance=self.config.WAYPOINT_TOLERANCE,
                timeout=120.0
            ):
                logger.warning(f"Timeout reaching target {target.id}")
                continue
            
            # Descend to drop altitude
            logger.info(f"Descending to drop altitude ({self.config.DROP_ALTITUDE}m)...")
            if not self.drone.goto(target.lat, target.lon, self.config.DROP_ALTITUDE):
                logger.warning("Failed to descend for drop")
                continue
            
            # Wait for descent
            if not self.drone.wait_for_altitude(
                self.config.DROP_ALTITUDE, 
                tolerance=1.0, 
                timeout=30.0
            ):
                logger.warning("Descent timeout, attempting drop anyway")
            
            # Drop payload
            self.drop_payload()
            
            # Ascend back to cruise altitude
            logger.info(f"Ascending to cruise altitude ({self.config.DELIVERY_ALTITUDE}m)...")
            self.drone.goto(target.lat, target.lon, self.config.DELIVERY_ALTITUDE)
            self.drone.wait_for_altitude(self.config.DELIVERY_ALTITUDE, tolerance=1.0, timeout=20.0)
            
            # Mark as delivered
            target.delivered = True
            self.deliveries_completed += 1
            
            logger.info(f"Delivery {self.deliveries_completed}/{len(self.targets)} complete")
        
        # 5. RTL - return to home position and land
        logger.info("\nBatch complete - Returning to home position...")
        self.drone.rtl()
        
        # Wait for landing at home
        logger.info("Waiting for landing at home position...")
        self.drone.wait_for_land(timeout=180.0)
        logger.info("Landed at home position")
        
        # Disconnect for refill
        self.drone.disconnect()
        
        return True
    
    def _cleanup(self):
        """Clean up resources."""
        if self.drone:
            self.drone.disconnect()
    
    def get_status(self) -> dict:
        """Get current mission status."""
        return {
            'running': self.running,
            'current_batch': self.current_batch_index,
            'total_batches': len(self.batches),
            'current_target': self.current_target_index,
            'deliveries_completed': self.deliveries_completed,
            'total_targets': len(self.targets)
        }


# =============================================================================
# STANDALONE EXECUTION
# =============================================================================
if __name__ == "__main__":
    import argparse
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
        datefmt='%H:%M:%S'
    )
    
    parser = argparse.ArgumentParser(description='Delivery Drone Payload Mission')
    parser.add_argument('--targets', help='Path to targets.json file')
    parser.add_argument('--connection', default='/dev/ttyUSB1',
                       help='Drone connection string')
    parser.add_argument('--capacity', type=int, default=5,
                       help='Payload capacity per flight')
    
    args = parser.parse_args()
    
    # Create configuration
    config = MissionConfig()
    config.DELIVERY_CONNECTION = args.connection
    config.PAYLOAD_CAPACITY = args.capacity
    
    # Run mission
    mission = DeliveryMission(config)
    
    if mission.setup():
        if mission.load_targets(args.targets):
            deliveries = mission.run()
            print(f"\nMission complete. {deliveries} deliveries made.")
        else:
            print("Failed to load targets!")
    else:
        print("Mission setup failed!")
